import h5py, re
import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize as opt

## define constants
e_charge = 1.6022e-19 # Coul

x_col = 0
y_col = 1
z_col = 2
drive_col = 7

#################################

def getdata(fname):

    cf = h5py.File(fname,'r')
    dset = cf['beads/data/pos_data']
    dat = np.transpose(dset)
    dat = dat / 3276.7 ## hard coded scaling from DAQ
    attribs = dset.attrs    
    
    data_dict={}

    data_dict['x'] = dat[:,x_col]
    data_dict['y'] = dat[:,y_col]
    data_dict['z'] = dat[:,z_col]
    data_dict['d'] = dat[:,drive_col]

    data_dict['attribs'] = attribs
    data_dict['file_handle'] = cf
    
    return data_dict


##### various sorting functions:  #####
def sort_by_stepZ(s):
    ### Sort by tilt in thetaZ
    cs = re.findall("-?\d+thetaZ.h5", s)
    return int(cs[0][:-9])

def sort_by_index(s):
    ### Sort by the integer just before h5
    cs = re.findall("\d+.h5", s)
    return int(cs[0][:-3])

def sort_by_index_and_tilt(s):
    ### Sort by the integer just before h5
    cs = re.findall("-?\d+thetaZ", s)
    if( len(cs) > 0 ):
        ztilt = np.abs(int(cs[0][:-6]))
    else:
        ztilt = 0
        
    cs = re.findall("-?\d+thetaY", s)
    if( len(cs) > 0):
        ytilt = np.abs(int(cs[0][:-6]))
    else:
        ytilt = 0
    
    cs = re.findall("\d+.h5", s)
    print ztilt, ytilt, int(cs[0][:-3]), ztilt*1e4 + ytilt*1e3 + int(cs[0][:-3])
    return ztilt*1e6 + ytilt*1e4 + int(cs[0][:-3])

def get_tilt(s,dir="Y"):
    cs = re.findall("-?\d+theta"+dir, s)
    if( len(cs) > 0):
        ytilt = int(cs[0][:-6])
    else:
        ytilt = 0
    return ytilt

def get_AC_volt(s):
    cs = re.findall("synth\d+mV", s)
    if( len(cs) > 0):
        volt = int(cs[0][5:-2])
    else:
        volt = 0
    return volt

def sort_by_index_and_volt(s):
    ### Sort by the integer just before h5
    cs = re.findall("synth\d+mV", s)
    if( len(cs) > 0):
        volt = int(cs[0][5:-2])
    else:
        volt = 0
    cs = re.findall("\d+.h5", s)
    return volt*1e-6 + int(cs[0][:-3])

        
#######################################
    
def corr_w_drive(x, d, amp = 1.0, offset = None, num_points = 100, make_plot=False):

    ## first fit the drive to the drive template
    # n_rep = np.ceil(len(d)/len(d_template))+1
    # full_template = np.tile(d_template,n_rep)[:len(d)]
    # ffn = lambda a: np.sum(np.abs( d-a*full_template ))
    # res = opt.minimize(ffn, [np.std(d),] )
    # amp = res.x 
    
    # plt.figure()
    # plt.plot(d)
    # plt.plot(amp*full_template)
    # plt.show()
    
    if( offset ):
        x = x[offset:]
        x -= np.mean(x)
        d = d[:-offset]
        d -= np.mean(d)
    else:
        x = x[num_points/2:-num_points/2+1]
        x -= np.mean(x)
        d -= np.mean(d)

    d2 = d**2
    d2 -= np.mean(d2)
        
    corr_vals = np.correlate( x,d )/(amp*len(x))

    if( offset ):
        cv, bp = corr_vals, offset
    else:
        best_pos = np.argmax( np.abs( corr_vals ) )
        cv, bp = corr_vals[best_pos], best_pos - num_points/2

    cv2 = np.correlate( x, d2 )/(amp**2 * len(x) )
    if(make_plot and not offset):
        print "Found best offset of: ", best_pos
        
        plt.figure()
        plt.plot( np.arange(num_points)-num_points/2, corr_vals )
        plt.plot( best_pos-num_points/2, corr_vals[best_pos], 'ro' )
        plt.show()

    return cv, bp, cv2

def calc_orthogonalize_pars(d):
    ## take a dictionary containing x, y, z traces and return gram-schmidt
    ## coefficients that orthoganalize the set, i.e. the orthogonal components
    ## are: 
    ##       z_orth = z
    ##       y_orth = y - <y,z_orth>/<z_orth,z_orth>*z
    ##       x_orth = x - <x,z_orth>/<z_orth,z_orth>*z - <x,y_orth>/<y_orth,y_orth>*y_orth
    ## where the returned coefficients are:  
    ##       c_yz = <y,z_orth>/<z_orth,z_orth>
    ##       c_xz = <x,z_orth>/<z_orth,z_orth>
    ##       c_xy = <x,y_orth>/<y_orth,y_orth>

    z_orth = d['z'] - np.median( d['z'] )
    y0 = d['y']- np.median( d['y'])
    c_yz = np.sum( y0*z_orth )/np.sum( z_orth**2 )
    y_orth = y0 - c_yz*z_orth
    x0 = d['x']
    c_xz = np.sum( x0*z_orth )/np.sum( z_orth**2 )
    c_xy = np.sum( x0*y_orth )/np.sum( y_orth**2 )
    x_orth = d['x'] - c_xz*z_orth - c_xy*y_orth

    return c_yz, c_xz, c_xy

def orthogonalize(xdat,ydat,zdat,c_yz,c_xz,c_xy):
    ## apply orthogonalization parameters generated by calc_orthogonalize pars
    zorth = zdat - np.median(zdat)
    yorth = ydat - np.median(ydat) - c_yz*zorth
    xorth = xdat - np.median(xdat) - c_xz*zorth - c_xy*yorth
    return xorth, yorth, zorth
